好的，这是对 `SlidingDetector.py` 文件的分析。

---

### 文件名: `interfaces/ordinary/SlidingDetector.py`

#### 核心功能总结

这个文件定义了一个名为 `SlidingDetector` (滑动检测器) 的类。它的主要功能是分析一系列连续的压力数据帧，以**检测并判断是否发生了“滑动”行为**。

其核心实现原理非常直观：通过追踪**压力中心 (Center of Pressure, CoP) 随时间的位置变化**来识别滑动。如果压力中心点从初始接触位置移动的距离超过了一个预设的阈值，系统就判定发生了滑动。

---

#### 详细功能分析

1.  **初始化 (`__init__`)**
    * 在创建实例时，可以配置三个关键参数：
        * `sliding_threshold`: **滑动阈值**。这是一个距离值（单位：像素），是判断是否滑动的关键依据。
        * `temporal_window`: **时间窗口**。定义了要存储多少帧历史数据，使用了 `collections.deque` 这一高效的数据结构。
        * `pressure_threshold`: **压力阈值**。用于过滤噪声，判断一个点是否为有效接触点。
    * 它还初始化了一系列内部状态变量，如 `is_contact` (是否接触)、`is_sliding` (是否在滑动)、`initial_cop` (初始接触时的压力中心)等。

2.  **核心逻辑 (`update_state` 方法)**
    * 这是该类的主要外部接口和工作函数，设计为一个**状态机**，每次有新的压力数据时被调用。
    * **第一步：接触判断**。首先，它会判断当前帧是否有有效的接触。如果完全没有接触，它会立刻**重置所有状态**，等待下一次新的接触。
    * **第二步：记录起点**。当检测到**“刚刚发生接触”**（即前一帧无接触，当前帧有接触）时，它会立刻记录下这一刻的压力中心位置，并将其保存为**“初始压力中心” (`initial_cop`)**。这个点是后续所有位移计算的参考原点。
    * **第三步：计算位移**。在**“持续接触”**的状态下，它会不断计算当前的压力中心相对于那个被记录下来的“初始压力中心”的直线距离。
    * **第四步：阈值判断**。将计算出的距离与预设的 `sliding_threshold` 进行比较：
        * 如果距离**大于**阈值，则将状态更新为 `is_sliding = True` (正在滑动)。
        * 如果距离**小于等于**阈值，则状态为 `is_sliding = False` (未滑动)，同时设置 `is_tangential = True`，表示可能存在切向力但物体还未移动。

3.  **状态获取 (`get_state_info` 方法)**
    * 这是一个简单的“getter”方法，用于向外部提供检测结果。
    * 它将所有的内部状态变量（是否接触、是否滑动、当前CoP、初始CoP、移动距离等）打包成一个字典返回，方便其他模块调用。

#### 在项目中的角色

`SlidingDetector.py` 是对整个系统分析能力的**一个重要扩展**。它使得系统不再仅仅能分析静态的力方向，而是具备了**初步的动态行为识别能力**。

在您的项目中，主窗口 (`EnhancedTangentialForceWidget`) 会在接收到每一帧新数据时，调用 `SlidingDetector` 的 `update_state` 方法。然后，它会调用 `get_state_info()` 获取包含 `is_sliding` 状态的字典，并通过**Qt信号**将这个信息广播出去。

像 `BoxPushDemoWidget` (推箱子演示) 这样的应用模块，就可以订阅这个信号。当它收到 `is_sliding = True` 的信号时，就可以播放箱子移动的动画；反之，则只显示推力而不移动。这使得分析结果能够直接驱动一个直观的、符合物理规律的可视化应用。