
---

### 文件名：`interfaces/ordinary/BoxPushDemoWidget.py`

#### 核心功能总结

这个文件定义了一个名为 `BoxPushDemoWidget` 的 **PyQt5 控件**。它的核心功能是创建一个**“推箱子”的动画演示界面**，用来**可视化地展示**从外部（可能是压力传感器分析模块）传入的关于**接触、切向力 和 滑动**的状态信息。

它将抽象的数据（如角度、距离）转换成一个直观的、物理意义上的动画：一个“手”推着一个“箱子”移动。

---

#### 详细功能分析

这个文件实际上包含了两个紧密协作的类：`BoxPushDemoWidget` 和 `BoxDemoCanvas`。

**1. `BoxPushDemoWidget` 类 (主框架)**

* **角色**: 这是整个控件的“外壳”和“控制器”。它负责创建用户界面布局、显示状态标签，并接收外部数据。
* **UI 布局**:
    * 它创建了一个垂直布局 (`QVBoxLayout`)。
    * 顶部是一个水平排列的状态区 (`QHBoxLayout`)，包含三个标签：
        * `contact_label` (接触状态): 显示“未接触”或“已接触”，并用边框颜色（红色/绿色）来强调。
        * `tangential_label` (切向力状态): 显示切向力的检测状态。
        * `sliding_label` (滑动状态): 显示是否正在发生滑动。
    * 中间是核心的动画区域，即 `BoxDemoCanvas` 的实例。
    * 底部是一个信息标签 (`info_label`)，用于以文本形式显示详细的实时数据。
* **数据接收 (`update_sliding_state` 方法)**:
    * 这是一个 **槽 (Slot)**，意味着它可以连接到其他模块的**信号 (Signal)**。
    * 当外部模块（如主程序）分析出新的滑动状态时，会调用这个方法，并传入一个包含所有相关信息的字典 (`sliding_info`)。
    * 接收到数据后，它会更新内部状态变量，并调用 `update_status_labels` 来刷新UI上的标签文本和颜色。
    * 最关键的是，它会将接收到的 `sliding_info` **传递给 `BoxDemoCanvas`**，让动画画布知道发生了什么。
* **动画驱动 (`QTimer`)**:
    * 它包含一个 `QTimer`，以固定的频率（每秒20次）触发 `update_animation` 方法。这个定时器是实现流畅动画的关键，它不断地“推进”动画的下一帧。

**2. `BoxDemoCanvas` 类 (动画画布)**

* **角色**: 这是实际进行动画绘制和物理模拟的“画布”。它是一个嵌入在 PyQt 控件中的 Matplotlib 图表。
* **可视化元素**:
    * 它在画布上绘制了几个关键图形元素（Matplotlib Patches）：
        * 一个方块 (`FancyBboxPatch`) 代表**箱子**。
        * 一个圆 (`Circle`) 代表**接触点**（可以想象成手指）。
        * 两个箭头 (`annotate`) 分别代表**施加的力**和**箱子的速度**。
* **物理模拟 (`_simulate_physics` 方法)**:
    * 这是该类的核心逻辑。它实现了一个简化的2D物理引擎。
    * 根据从 `BoxPushDemoWidget` 传来的数据（特别是 `consensus_angle` 和 `movement_distance`）计算出施加在箱子上的**推力**。
    * 它还模拟了**摩擦力**（与运动方向相反）和**阻尼**（使箱子最终能停下来）。
    * 通过牛顿第二定律 (`F=ma`) 计算加速度，并更新箱子的速度和位置。
    * 它还处理了**边界碰撞**，确保箱子不会移出画布。
* **动画更新 (`update_visuals` 方法)**:
    * 这个方法被定时器周期性地调用。
    * 在每一帧，它首先调用 `_simulate_physics` 来计算箱子在下一个瞬间的新位置。
    * 然后，它更新画布上所有图形元素（箱子、接触点、箭头）的位置、角度和可见性。
    * 最后调用 `self.draw()` 来重绘整个画布，从而在屏幕上呈现出动态效果。

---

**工作流程总结**

1.  外部程序（主应用）捕捉并分析压力数据。
2.  分析结果（是否接触、是否滑动、滑动方向等）被打包成一个字典。
3.  这个字典通过信号-槽机制被发送到 `BoxPushDemoWidget` 的 `update_sliding_state` 方法。
4.  `BoxPushDemoWidget` 更新UI标签，并将数据转发给 `BoxDemoCanvas`。
5.  `BoxDemoCanvas` 根据新数据设置其内部的“力”的大小和方向。
6.  `QTimer` 不断触发 `BoxDemoCanvas` 的 `update_visuals` 方法。
7.  在每一帧，`update_visuals` 运行物理模拟，计算箱子的新位置，并重绘所有图形。
8.  最终用户看到的就是一个根据实时数据反馈而移动的箱子动画。

**总而言之，`BoxPushDemoWidget.py` 是一个优秀的数据可视化模块，它将枯燥的传感器数据转换成了一个生动、直观的物理动画，极大地增强了系统的交互性和可理解性。**
